(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{184:function(t,e,_){"use strict";_.r(e);var v=_(0),i=Object(v.a)({},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),_("p",[t._v("当出现优先级相等的情况时，最晚出现的样式规则会被采纳。如果你在样式表里写了相同的规则（无论是在该文件内部还是其它样式文件中），那么最后出现的（在文件底部的）样式优先级更高，因此会被采纳。")]),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),_("p",[t._v("当需要实现非常个性化的网页设计时，我会选择重置的方式，因为我要写很多自定义的样式以满足设计需求，这时候就不再需要标准化的默认样式了。")]),t._v(" "),t._m(8),t._v(" "),_("p",[t._v("浮动（float）是 CSS 定位属性。浮动元素从网页的正常流动中移出，但是保持了部分的流动性，会影响其他元素的定位（比如文字会围绕着浮动元素）。这一点与绝对定位不同，绝对定位的元素完全从文档流中脱离。")]),t._v(" "),t._m(9),t._v(" "),_("p",[t._v("如果父元素只包含浮动元素，那么该父元素的高度将塌缩为 0。我们可以通过清除（clear）从浮动元素后到父元素关闭前之间的浮动来修复这个问题。")]),t._v(" "),_("p",[t._v("有一种 hack 的方法，是自定义一个"),_("code",[t._v(".clearfix")]),t._v("类，利用伪元素选择器"),_("code",[t._v("::after")]),t._v("清除浮动。"),_("a",{attrs:{href:"https://css-tricks.com/all-about-floats/#article-header-id-4",target:"_blank",rel:"noopener noreferrer"}},[t._v("另外还有一些方法"),_("OutboundLink")],1),t._v("，比如添加空的"),_("code",[t._v("<div></div>")]),t._v("和设置浮动元素父元素的"),_("code",[t._v("overflow")]),t._v("属性。与这些方法不同的是，"),_("code",[t._v("clearfix")]),t._v("方法，只需要给父元素添加一个类，定义如下：")]),t._v(" "),t._m(10),t._m(11),t._v(" "),t._m(12),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),t._m(15),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),_("p",[t._v("块格式上下文（BFC）是 Web 页面的可视化 CSS 渲染的部分，是块级盒布局发生的区域，也是浮动元素与其他元素交互的区域。")]),t._v(" "),_("p",[t._v("一个 HTML 盒（Box）满足以下任意一条，会创建块格式化上下文：")]),t._v(" "),t._m(18),t._v(" "),_("p",[t._v("在 BFC 中，每个盒的左外边缘都与其包含的块的左边缘相接。")]),t._v(" "),_("p",[t._v("两个相邻的块级盒在垂直方向上的边距会发生合并（collapse）。")]),t._v(" "),t._m(19),t._v(" "),t._m(20),t._v(" "),t._m(21),t._v(" "),t._m(22),t._v(" "),_("p",[t._v("雪碧图是把多张图片整合到一张上的图片。它被运用在众多使用了很多小图标的网站上（Gmail 在使用）。实现方法：")]),t._v(" "),t._m(23),t._v(" "),_("p",[t._v("好处：")]),t._v(" "),t._m(24),t._v(" "),t._m(25),t._v(" "),t._m(26),t._v(" "),t._m(27),t._v(" "),_("ul",[_("li",[t._v("优雅的降级：为现代浏览器构建应用，同时确保它在旧版浏览器中正常运行。")]),t._v(" "),_("li",[t._v("渐进式增强：构建基于用户体验的应用，但在浏览器支持时添加新增功能。")]),t._v(" "),_("li",[t._v("利用 "),_("a",{attrs:{href:"https://caniuse.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("caniuse.com"),_("OutboundLink")],1),t._v(" 检查特性支持。")]),t._v(" "),t._m(28),t._v(" "),_("li",[t._v("使用 "),_("a",{attrs:{href:"https://modernizr.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Modernizr"),_("OutboundLink")],1),t._v("进行特性检测。")])]),t._v(" "),t._m(29),t._v(" "),_("p",[t._v("这些方法与可访问性（a11y）有关。")]),t._v(" "),t._m(30),t._v(" "),_("p",[t._v("即使 WAI-ARIA 是理想的解决方案，我也会采用绝对定位方法，因为它具有最少的注意事项，适用于大多数元素，而且使用起来非常简单。")]),t._v(" "),t._m(31),t._v(" "),t._m(32),t._v(" "),_("p",[t._v("CSS 盒模型负责计算：")]),t._v(" "),t._m(33),t._v(" "),_("p",[t._v("盒模型有以下规则：")]),t._v(" "),t._m(34),t._v(" "),t._m(35),t._v(" "),t._m(36),t._v(" "),t._m(37),t._v(" "),t._m(38),t._v(" "),t._m(39),t._v(" "),t._m(40),t._v(" "),t._m(41),t._v(" "),t._m(42)])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"css-问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css-问题","aria-hidden":"true"}},[this._v("#")]),this._v(" CSS 问题")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"css-选择器的优先级是如何计算的？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css-选择器的优先级是如何计算的？","aria-hidden":"true"}},[this._v("#")]),this._v(" CSS 选择器的优先级是如何计算的？")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("浏览器通过优先级规则，判断元素展示哪些样式。优先级通过 4 个维度指标确定，我们假定以"),e("code",[this._v("a、b、c、d")]),this._v("命名，分别代表以下含义：")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ol",[_("li",[_("code",[t._v("a")]),t._v("表示是否使用内联样式（inline style）。如果使用，"),_("code",[t._v("a")]),t._v("为 1，否则为 0。")]),t._v(" "),_("li",[_("code",[t._v("b")]),t._v("表示 ID 选择器的数量。")]),t._v(" "),_("li",[_("code",[t._v("c")]),t._v("表示类选择器、属性选择器和伪类选择器数量之和。")]),t._v(" "),_("li",[_("code",[t._v("d")]),t._v("表示标签（类型）选择器和伪元素选择器之和。")])])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("p",[t._v("优先级的结果并非通过以上四个值生成一个得分，而是每个值分开比较。"),_("code",[t._v("a、b、c、d")]),t._v("权重从左到右，依次减小。判断优先级时，从左到右，一一比较，直到比较出最大值，即可停止。所以，如果"),_("code",[t._v("b")]),t._v("的值不同，那么"),_("code",[t._v("c")]),t._v("和"),_("code",[t._v("d")]),t._v("不管多大，都不会对结果产生影响。比如"),_("code",[t._v("0，1，0，0")]),t._v("的优先级高于"),_("code",[t._v("0，0，10，10")]),t._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("在写样式时，我会使用较低的优先级，这样这些样式可以轻易地覆盖掉。尤其对写 UI 组件的时候更为重要，这样使用者就不需要通过非常复杂的优先级规则或使用"),e("code",[this._v("!important")]),this._v("的方式，去覆盖组件的样式了。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"重置（resetting）css-和-标准化（normalizing）css-的区别是什么？你会选择哪种方式，为什么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重置（resetting）css-和-标准化（normalizing）css-的区别是什么？你会选择哪种方式，为什么？","aria-hidden":"true"}},[this._v("#")]),this._v(" 重置（resetting）CSS 和 标准化（normalizing）CSS 的区别是什么？你会选择哪种方式，为什么？")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("strong",[t._v("重置（Resetting）")]),t._v("： 重置意味着除去所有的浏览器默认样式。对于页面所有的元素，像"),_("code",[t._v("margin")]),t._v("、"),_("code",[t._v("padding")]),t._v("、"),_("code",[t._v("font-size")]),t._v("这些样式全部置成一样。你将必须重新定义各种元素的样式。")]),t._v(" "),_("li",[_("strong",[t._v("标准化（Normalizing）")]),t._v("： 标准化没有去掉所有的默认样式，而是保留了有用的一部分，同时还纠正了一些常见错误。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"请阐述float定位的工作原理。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请阐述float定位的工作原理。","aria-hidden":"true"}},[this._v("#")]),this._v(" 请阐述"),e("code",[this._v("Float")]),this._v("定位的工作原理。")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("p",[t._v("CSS 的"),_("code",[t._v("clear")]),t._v("属性通过使用"),_("code",[t._v("left")]),t._v("、"),_("code",[t._v("right")]),t._v("、"),_("code",[t._v("both")]),t._v("，让该元素向下移动（清除浮动）到浮动元素下面。")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("div",{staticClass:"language-css extra-class"},[_("pre",{pre:!0,attrs:{class:"language-css"}},[_("code",[_("span",{pre:!0,attrs:{class:"token selector"}},[t._v(".clearfix::after")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),_("span",{pre:!0,attrs:{class:"token property"}},[t._v("content")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),_("span",{pre:!0,attrs:{class:"token string"}},[t._v("''")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),_("span",{pre:!0,attrs:{class:"token property"}},[t._v("display")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" block"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),_("span",{pre:!0,attrs:{class:"token property"}},[t._v("clear")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" both"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("值得一提的是，把父元素属性设置为"),e("code",[this._v("overflow: auto")]),this._v("或"),e("code",[this._v("overflow: hidden")]),this._v("，会使其内部的子元素形成块格式化上下文（Block Formatting Context），并且父元素会扩张自己，使其能够包围它的子元素。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"请阐述z-index属性，并说明如何形成层叠上下文（stacking-context）。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请阐述z-index属性，并说明如何形成层叠上下文（stacking-context）。","aria-hidden":"true"}},[this._v("#")]),this._v(" 请阐述"),e("code",[this._v("z-index")]),this._v("属性，并说明如何形成层叠上下文（stacking context）。")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("p",[t._v("CSS 中的"),_("code",[t._v("z-index")]),t._v("属性控制重叠元素的垂直叠加顺序。"),_("code",[t._v("z-index")]),t._v("只能影响"),_("code",[t._v("position")]),t._v("值不是"),_("code",[t._v("static")]),t._v("的元素。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("没有定义"),e("code",[this._v("z-index")]),this._v("的值时，元素按照它们出现在 DOM 中的顺序堆叠（层级越低，出现位置越靠上）。非静态定位的元素（及其子元素）将始终覆盖静态定位（static）的元素，而不管 HTML 层次结构如何。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("层叠上下文是包含一组图层的元素。 在一组层叠上下文中，其子元素的"),e("code",[this._v("z-index")]),this._v("值是相对于该父元素而不是 document root 设置的。每个层叠上下文完全独立于它的兄弟元素。如果元素 B 位于元素 A 之上，则即使元素 A 的子元素 C 具有比元素 B 更高的"),e("code",[this._v("z-index")]),this._v("值，元素 C 也永远不会在元素 B 之上.")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("p",[t._v("每个层叠上下文是自包含的：当元素的内容发生层叠后，整个该元素将会在父层叠上下文中按顺序进行层叠。少数 CSS 属性会触发一个新的层叠上下文，例如"),_("code",[t._v("opacity")]),t._v("小于 1，"),_("code",[t._v("filter")]),t._v("不是"),_("code",[t._v("none")]),t._v("，"),_("code",[t._v("transform")]),t._v("不是"),_("code",[t._v("none")]),t._v("。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"请阐述块格式化上下文（block-formatting-context）及其工作原理。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请阐述块格式化上下文（block-formatting-context）及其工作原理。","aria-hidden":"true"}},[this._v("#")]),this._v(" 请阐述块格式化上下文（Block Formatting Context）及其工作原理。")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("code",[t._v("float")]),t._v("的值不是"),_("code",[t._v("none")]),t._v(".")]),t._v(" "),_("li",[_("code",[t._v("position")]),t._v("的值不是"),_("code",[t._v("static")]),t._v("或"),_("code",[t._v("relative")]),t._v(".")]),t._v(" "),_("li",[_("code",[t._v("display")]),t._v("的值是"),_("code",[t._v("table-cell")]),t._v("、"),_("code",[t._v("table-caption")]),t._v("、"),_("code",[t._v("inline-block")]),t._v("、"),_("code",[t._v("flex")]),t._v("、或"),_("code",[t._v("inline-flex")]),t._v("。")]),t._v(" "),_("li",[_("code",[t._v("overflow")]),t._v("的值不是"),_("code",[t._v("visible")]),t._v("。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"有哪些清除浮动的技术，都适用哪些情况？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#有哪些清除浮动的技术，都适用哪些情况？","aria-hidden":"true"}},[this._v("#")]),this._v(" 有哪些清除浮动的技术，都适用哪些情况？")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[t._v("空"),_("code",[t._v("div")]),t._v("方法："),_("code",[t._v('<div style="clear:both;"></div>')]),t._v("。")]),t._v(" "),_("li",[t._v("Clearfix 方法：上文使用"),_("code",[t._v(".clearfix")]),t._v("类已经提到。")]),t._v(" "),_("li",[_("code",[t._v("overflow: auto")]),t._v("或"),_("code",[t._v("overflow: hidden")]),t._v("方法：上文已经提到。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("在大型项目中，我会使用 Clearfix 方法，在需要的地方使用"),e("code",[this._v(".clearfix")]),this._v("。设置"),e("code",[this._v("overflow: hidden")]),this._v("的方法可能使其子元素显示不完整，当子元素的高度大于父元素时。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"请解释什么是雪碧图（css-sprites），以及如何实现？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请解释什么是雪碧图（css-sprites），以及如何实现？","aria-hidden":"true"}},[this._v("#")]),this._v(" 请解释什么是雪碧图（css sprites），以及如何实现？")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ol",[_("li",[t._v("使用生成器将多张图片打包成一张雪碧图，并为其生成合适的 CSS。")]),t._v(" "),_("li",[t._v("每张图片都有相应的 CSS 类，该类定义了"),_("code",[t._v("background-image")]),t._v("、"),_("code",[t._v("background-position")]),t._v("和"),_("code",[t._v("background-size")]),t._v("属性。")]),t._v(" "),_("li",[t._v("使用图片时，将相应的类添加到你的元素中。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("减少加载多张图片的 HTTP 请求数（一张雪碧图只需要一个请求）。但是对于 HTTP2 而言，加载多张图片不再是问题。")]),this._v(" "),e("li",[this._v("提前加载资源，防止在需要时才在开始下载引发的问题，比如只出现在"),e("code",[this._v(":hover")]),this._v("伪类中的图片，不会出现闪烁。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"如何解决不同浏览器的样式兼容性问题？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何解决不同浏览器的样式兼容性问题？","aria-hidden":"true"}},[this._v("#")]),this._v(" 如何解决不同浏览器的样式兼容性问题？")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[t._v("在确定问题原因和有问题的浏览器后，使用单独的样式表，仅供出现问题的浏览器加载。这种方法需要使用服务器端渲染。")]),t._v(" "),_("li",[t._v("使用已经处理好此类问题的库，比如 Bootstrap。")]),t._v(" "),_("li",[t._v("使用 "),_("code",[t._v("autoprefixer")]),t._v(" 自动生成 CSS 属性前缀。")]),t._v(" "),_("li",[t._v("使用 Reset CSS 或 Normalize.css。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"如何为功能受限的浏览器提供页面？-使用什么样的技术和流程？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何为功能受限的浏览器提供页面？-使用什么样的技术和流程？","aria-hidden":"true"}},[this._v("#")]),this._v(" 如何为功能受限的浏览器提供页面？ 使用什么样的技术和流程？")])},function(){var t=this.$createElement,e=this._self._c||t;return e("li",[this._v("使用 "),e("code",[this._v("autoprefixer")]),this._v(" 自动生成 CSS 属性前缀。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？","aria-hidden":"true"}},[this._v("#")]),this._v(" 有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("code",[t._v("visibility: hidden")]),t._v("：元素仍然在页面流中，并占用空间。")]),t._v(" "),_("li",[_("code",[t._v("width: 0; height: 0")]),t._v("：使元素不占用屏幕上的任何空间，导致不显示它。")]),t._v(" "),_("li",[_("code",[t._v("position: absolute; left: -99999px")]),t._v("： 将它置于屏幕之外。")]),t._v(" "),_("li",[_("code",[t._v("text-indent: -9999px")]),t._v("：这只适用于"),_("code",[t._v("block")]),t._v("元素中的文本。")]),t._v(" "),_("li",[t._v("Metadata： 例如通过使用 Schema.org，RDF 和 JSON-LD。")]),t._v(" "),_("li",[t._v("WAI-ARIA：如何增加网页可访问性的 W3C 技术规范。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"说说你对盒模型的理解，以及如何告知浏览器使用不同的盒模型渲染布局。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说说你对盒模型的理解，以及如何告知浏览器使用不同的盒模型渲染布局。","aria-hidden":"true"}},[this._v("#")]),this._v(" 说说你对盒模型的理解，以及如何告知浏览器使用不同的盒模型渲染布局。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("CSS 盒模型描述了以文档树中的元素而生成的矩形框，并根据排版模式进行布局。每个盒子都有一个内容区域（例如文本，图像等）以及周围可选的"),e("code",[this._v("padding")]),this._v("、"),e("code",[this._v("border")]),this._v("和"),e("code",[this._v("margin")]),this._v("区域。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("块级元素占用多少空间。")]),this._v(" "),e("li",[this._v("边框是否重叠，边距是否合并。")]),this._v(" "),e("li",[this._v("盒子的尺寸。")])])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[t._v("块级元素的大小由"),_("code",[t._v("width")]),t._v("、"),_("code",[t._v("height")]),t._v("、"),_("code",[t._v("padding")]),t._v("、"),_("code",[t._v("border")]),t._v("和"),_("code",[t._v("margin")]),t._v("决定。")]),t._v(" "),_("li",[t._v("如果没有指定"),_("code",[t._v("height")]),t._v("，则块级元素的高度等于其包含子元素的内容高度加上"),_("code",[t._v("padding")]),t._v("（除非有浮动元素，请参阅下文）。")]),t._v(" "),_("li",[t._v("如果没有指定"),_("code",[t._v("width")]),t._v("，则非浮动块级元素的宽度等于其父元素的宽度减去父元素的"),_("code",[t._v("padding")]),t._v("。")]),t._v(" "),_("li",[t._v("元素的"),_("code",[t._v("height")]),t._v("是由内容的"),_("code",[t._v("height")]),t._v("来计算的。")]),t._v(" "),_("li",[t._v("元素的"),_("code",[t._v("width")]),t._v("是由内容的"),_("code",[t._v("width")]),t._v("来计算的。")]),t._v(" "),_("li",[t._v("默认情况下，"),_("code",[t._v("padding")]),t._v("和"),_("code",[t._v("border")]),t._v("不是元素"),_("code",[t._v("width")]),t._v("和"),_("code",[t._v("height")]),t._v("的组成部分。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"box-sizing-border-box-会产生怎样的效果？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#box-sizing-border-box-会产生怎样的效果？","aria-hidden":"true"}},[this._v("#")]),this._v(" "),e("code",[this._v("* { box-sizing: border-box; }")]),this._v("会产生怎样的效果？")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[t._v("元素默认应用了"),_("code",[t._v("box-sizing: content-box")]),t._v("，元素的宽高只会决定内容（content）的大小。")]),t._v(" "),_("li",[_("code",[t._v("box-sizing: border-box")]),t._v("改变计算元素"),_("code",[t._v("width")]),t._v("和"),_("code",[t._v("height")]),t._v("的方式，"),_("code",[t._v("border")]),t._v("和"),_("code",[t._v("padding")]),t._v("的大小也将计算在内。")]),t._v(" "),_("li",[t._v("元素的"),_("code",[t._v("height")]),t._v(" = 内容（content）的高度 + 垂直方向的"),_("code",[t._v("padding")]),t._v(" + 垂直方向"),_("code",[t._v("border")]),t._v("的宽度")]),t._v(" "),_("li",[t._v("元素的"),_("code",[t._v("width")]),t._v(" = 内容（content）的宽度 + 水平方向的"),_("code",[t._v("padding")]),t._v(" + 水平方向"),_("code",[t._v("border")]),t._v("的宽度")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"inline和inline-block有什么区别？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#inline和inline-block有什么区别？","aria-hidden":"true"}},[this._v("#")]),this._v(" "),e("code",[this._v("inline")]),this._v("和"),e("code",[this._v("inline-block")]),this._v("有什么区别？")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("我把"),e("code",[this._v("block")]),this._v("也加入其中，为了获得更好的比较。")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("table",[_("thead",[_("tr",[_("th"),t._v(" "),_("th",[_("strong",[t._v("block")])]),t._v(" "),_("th",[_("strong",[t._v("inline-block")])]),t._v(" "),_("th",[_("strong",[t._v("inline")])])])]),t._v(" "),_("tbody",[_("tr",[_("td",[_("strong",[t._v("大小")])]),t._v(" "),_("td",[t._v("填充其父容器的宽度。")]),t._v(" "),_("td",[t._v("取决于内容。")]),t._v(" "),_("td",[t._v("取决于内容。")])]),t._v(" "),_("tr",[_("td",[_("strong",[t._v("定位")])]),t._v(" "),_("td",[t._v("从新的一行开始，并且不允许旁边有 HTML 元素（除非是"),_("code",[t._v("float")]),t._v("）")]),t._v(" "),_("td",[t._v("与其他内容一起流动，并允许旁边有其他元素。")]),t._v(" "),_("td",[t._v("与其他内容一起流动，并允许旁边有其他元素。")])]),t._v(" "),_("tr",[_("td",[_("strong",[t._v("能否设置"),_("code",[t._v("width")]),t._v("和"),_("code",[t._v("height")])])]),t._v(" "),_("td",[t._v("能")]),t._v(" "),_("td",[t._v("能")]),t._v(" "),_("td",[t._v("不能。 设置会被忽略。")])]),t._v(" "),_("tr",[_("td",[_("strong",[t._v("可以使用"),_("code",[t._v("vertical-align")]),t._v("对齐")])]),t._v(" "),_("td",[t._v("不可以")]),t._v(" "),_("td",[t._v("可以")]),t._v(" "),_("td",[t._v("可以")])]),t._v(" "),_("tr",[_("td",[_("strong",[t._v("边距（margin）和填充（padding）")])]),t._v(" "),_("td",[t._v("各个方向都存在")]),t._v(" "),_("td",[t._v("各个方向都存在")]),t._v(" "),_("td",[t._v("只有水平方向存在。垂直方向会被忽略。 尽管"),_("code",[t._v("border")]),t._v("和"),_("code",[t._v("padding")]),t._v("在"),_("code",[t._v("content")]),t._v("周围，但垂直方向上的空间取决于'line-height'")])]),t._v(" "),_("tr",[_("td",[_("strong",[t._v("浮动（float）")])]),t._v(" "),_("td",[t._v("-")]),t._v(" "),_("td",[t._v("-")]),t._v(" "),_("td",[t._v("就像一个"),_("code",[t._v("block")]),t._v("元素，可以设置垂直边距和填充。")])])])])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("h2",{attrs:{id:"relative、fixed、absolute和static四种定位有什么区别？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#relative、fixed、absolute和static四种定位有什么区别？","aria-hidden":"true"}},[t._v("#")]),t._v(" "),_("code",[t._v("relative")]),t._v("、"),_("code",[t._v("fixed")]),t._v("、"),_("code",[t._v("absolute")]),t._v("和"),_("code",[t._v("static")]),t._v("四种定位有什么区别？")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("p",[t._v("经过定位的元素，其"),_("code",[t._v("position")]),t._v("属性值必然是"),_("code",[t._v("relative")]),t._v("、"),_("code",[t._v("absolute")]),t._v("、"),_("code",[t._v("fixed")]),t._v("或"),_("code",[t._v("sticky")]),t._v("。")])},function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("ul",[_("li",[_("code",[t._v("static")]),t._v("：默认定位属性值。该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。")]),t._v(" "),_("li",[_("code",[t._v("relative")]),t._v("：该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。")]),t._v(" "),_("li",[_("code",[t._v("absolute")]),t._v("：不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。")]),t._v(" "),_("li",[_("code",[t._v("fixed")]),t._v("：不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。")]),t._v(" "),_("li",[_("code",[t._v("sticky")]),t._v("：盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 "),_("code",[t._v("table")]),t._v(" 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。"),_("code",[t._v("position: sticky")]),t._v(" 对 "),_("code",[t._v("table")]),t._v(" 元素的效果与 "),_("code",[t._v("position: relative")]),t._v(" 相同。")])])}],!1,null,null,null);e.default=i.exports}}]);